
# Efficient Fuzzy PSI Based on Prefix Representation

## Introduction

Fuzzy PSI is a variant of PSI, which on input a set of points from the receiver and sender respectively, allows the receiver to learn which of the senderâ€™s points lie within a threshold distance ð›¿ under a specific distance metric.

This work explores the use of ***prefix techniques*** to significantly improve the efficiency of fuzzy PSI protocols. By integrating spatial hashing, we develop efficient fuzzy PSI protocols for ***low-dimensional*** spaces. For ***high-dimensional*** settings, we present the first fuzzy PSI protocols achieving communication and computation complexity that scales logarithmically in ð›¿ and linearly in dimension ð‘‘ and input set sizes.

## Project Structure

The following is the structure description of this project. We have provided some scripts to assist with building and running tests. Please grant execute permissions to these scripts, all of which are designed to be run from the project root directory.

```
ourFuzzyPSI-C/
â”œâ”€â”€ fpsi/                    # Core FPSI protocol code
â”œâ”€â”€ frontend/                # Front-end interface
â”œâ”€â”€ thirdparty/              # Third-party dependencies
â”œâ”€â”€ build/                   # Build output directory
â”œâ”€â”€ README.md                # Project documentation
â”œâ”€â”€ CMakeLists.txt           # CMake build configuration file
â”œâ”€â”€ Dockerfile               # Docker image build file
â”œâ”€â”€ shell_install_all_dependencies.sh # Dependency installation script 
â”œâ”€â”€ shell_build_cmd.sh       # Local build script
â”œâ”€â”€ shell_run_bench.sh       # Benchmark run script
â”œâ”€â”€ shell_utils.sh           # Shell utility functions
```

## Build and Run

### Prerequisites

- **Compatibility Confirmed**: *Ubuntu 20.04+* operating systems meet all project runtime specifications.

- **Hardware Requirements**:
Our project utilizes [pailliercryptolib](https://github.com/intel/pailliercryptolib.git) for homomorphic encryption. `Pailliercryptolib` is to be used on `AVX512IFMA` enabled systems, as listed below in Intel CPU codenames: *Intel Cannon Lake
,Intel Ice Lake, Intel Sapphire Rapids*. But for better performance, it is recommended to use the library on Intel XeonÂ® scalable processors - Ice Lake-SP or Sapphire Rapids-SP Xeon CPUs while fully utilizing the features.

- `GCC 13` is required to ensure full *C++20* support. Please verify your `GCC` version.

### Local Build and Run

#### Step 1: Dependencies

Must have dependencies include:

```bash
cmake > 3.22
git
python3
libgmp-dev
libspdlog-dev
libssl-dev
libmpfr-dev
libfmt-dev
libtool
nasm
```

#### Step 2: Installing Third-Party Dependencies

There are mandatory dependencies on [libOTe](https://github.com/osu-crypto/libOTe.git) (multiple cryptographic primitive), [pailliercryptolib](https://github.com/intel/pailliercryptolib.git) (homomorphic encryption) and [Blake3](https://github.com/BLAKE3-team/BLAKE3.git) (hash function).

Run the `shell_install_all_dependencies.sh` script for automated dependency compilation and installation.

<!-- To accelerate the build process, please ensure [boost_1_86_0.tar.bz2](https://archives.boost.io/release/1.86.0/source/boost_1_86_0.tar.bz2) exists in the `./thirdparty` directory. If not, the stripts will occur errors. -->

#### Step 3: Build the Executable File

Running `shell_build_cmd.sh` produces deployable artifacts `main` in folder `./build`.

#### Step 4: Run benchmarks

Running `shell_run_bench.sh` to reproduce the experimental results from Table 3 in our paper.

As illustrated in the figure below, the left portion contains *the reference data from Table 3 of our paper*, while the right portion exhibits typical output produced by the `shell_run_bench.sh` script.

More data may be generated by running the compiled executable `./build/main` with appropriate parameters.

![benchmarks](./benchmarks.png)

### Docker Build (Recommend!15 mins)

Verified support for *Docker version 28.3.3 and later*. Earlier versions have not been validated.

```bash
# build docker image 
docker build -t fpsi_artifact .

# run the docker container with the necessary capabilities
docker run -it --cap-add=NET_ADMIN --rm fpsi_artifact bash

# installs all necessary dependencies for the project
./shell_install_all_dependencies.sh

# build executable file
./shell_build_cmd.sh

# in container workdir, run benchmarks stript
./shell_run_bench.sh
```

In our image, we use [tcconfig](!https://github.com/thombashi/tcconfig) to set up traffic control of network bandwidth/latency. Usage instructions are provided below.

```bash
tcset lo --rate 10Gbps --overwrite               # Set the local loopback interface bandwidth to 10Gbps
tcset lo --rate 1Gbps --delay 5ms --overwrite    # Set bandwidth to 1Gbps and add 5ms network delay
tcset lo --rate 100Mbps --delay 20ms --overwrite # Set bandwidth to 100Mbps and add 20ms network delay
tcshow lo                                        # Display current traffic control settings for the loopback interface
tcdel lo -a                                      # Remove all traffic control rules from the loopback interface
```

## Usage Guide for `./build/main`

This section describes the usage of the executable file located at `./build/main`.

#### Command Flags

| Flag | Meaning             | Optional Values                                |
|:----:|:-------------------:|----------------------------------------------|
| p    | Protocol Type       | `1`: Single-run low-dimensional protocol<br/>`2`: Single-run high-dimensional protocol<br/>`3`: Batch low-dimensional protocol<br/>`4`: Batch high-dimensional protocol |
| d    | Dimension           | Tested dimensions: `2`, `5`, `8`<br />default value 2 for low-dimensional protocol, 5 for high-dimensional protocol |
| m    | Metric              | `0`: L<sub>âˆž</sub>(default)<br />`1`: L<sub>1</sub><br />`2`: L<sub>2</sub> |
| delta| Radius              | Only for `16`(default), `32`, `64`, `128`, `256`       |
| n    | The logarithm of the input set size | Tested values: `4`, `8`(default), `12` (only supports balanced case) |
| log | log level | `0`: off, `1`: info(default), `2`: debug, `3`: error |
| trait | Batch test quantity configuration | 1 (default value) |

#### Usage samples

```bash
# low dimension L_inf 
./main -p 3 -d 2 -m 0 -n 4 -delta 16 -i 2

# high dimension L_2
./main -p 4 -d 5 -m 2 -n 8 -delta 16 -i 4
```
